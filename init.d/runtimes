#!/sbin/runscript

# The purpose of this script is to load the Alpine runtime modules and the 
# local config that belongs to.

SFIC=`which sfic 2>/dev/null`
COMMITED_TDB=/var/lib/apk/commited.tdb
TMP=/tmp/init.d-runtimes

# search for a kernel argument
get_kopt () {
	for i in `cat /proc/cmdline` ; do
		case $i in
			$1=*) echo $i | sed 's|'$1'=||'
			return 0
			;;
        	esac
	done
	return 1
}

get_pkg_list() {
#	# we skip lines that start with '#'
#	grep -v '^#' $1 | while read pkg ; do
#		for i in $pkg ; do
#			echo -n "$pkg "
#		done
#	done 
	sed 's/\#.*//' $1
}

preload_users_and_groups() {
	tar -C / -zxf "$1" etc/passwd etc/group 2>/dev/null
}

# merge the unpacked config
merge_config() {
	local dev mnt ovl f ovllist ovlfile
	dev=$1
	ovlfile="$2"
	mnt=$(dirname "$2")
	ovl=$(basename "$2")

	cp -ar $TMP/* /

	# remember to remove leading /
	ovllist=`find $TMP/* | sed "s:^$TMP/::"`
	if [ "$ovllist" ] ; then
		lbu update $ovllist 2>/dev/null
		return 0
	else
		return 1
	fi
}

find_ovl() {
	local mnt="$1"
	local ovl
	local lines
	# first search kernel cmdline for "pkg_ovl"
	ovl=$( get_kopt pkg_ovl )
	if [ x"$ovl" != x ] ;then
		echo "$ovl"
		return 0
	fi

	# look for apkovl's on mounted media
	ovl=$( ls -1 "$mnt"/*.apkovl.tar.gz 2>/dev/null ) || return 1
	lines=$(echo "$ovl" | wc -l)

	if [ $lines -gt 1 ] ; then
		# output the last line only
		ovl=$(echo "$ovl" | tail -n 1)
		echo "Warning: more than one apkovl file was found. Only $ovl will be used." >&2
	fi
	echo "$ovl"
}

# read ahead so the packages are in cache when installed
readahead_pkgs() {
	local i pkgs
	for i in $* ; do
		pkgs="$pkgs $APK_PATH_MOUNTED/$i-[0-9]*"
	done
	readahead $pkgs 2>/dev/null &
}
	
load_pkgs_from_list() {
	local list="$1"
	local prompt="$2"
	local pkgs pkg
	apk_fetch -u -q
	pkgs=$( sed 's/\#.*//' "$list" )
	readahead_pkgs $pkgs
	for pkg in $pkgs ; do
		apk_add -q $pkg && echo -n '.'
	done
}

load_pkgs() {
	local pkglist mlist pkg pkgs
	local dev=$1
	local mnt=$2
	# get kernel opt pkg_list or use /packages.list
	pkglist=`get_kopt pkg_list`
	# here we should issue a warning in future versions if found on cmdline
	pkglist=${pkglist:-/packages.list}

	mlist="$mnt/$pkglist"
	wlist="$TMP/var/lib/apk/world"
	if [ -f "$wlist" ] ; then
		load_pkgs_from_list "$wlist"
		# its re-generated
		rm -rf "$wlist"
	elif [ -f "$mlist" ] ; then
		#ok, we are upgrading...
		local line i
		load_pkgs_from_list "$mlist"
		# lets clean up the world file
		for i in $(apk_glob '*') ; do
			reqby=$(apk_info -qr $i);
			# only add the packages who has no REQUIRED_BY
			[ -z "$reqby" ] && echo $i
		done | sed 's/-[0-9].*//' > /var/lib/apk/world		
	fi
}

# load packages from mounted media
load_pkgs_and_config() {
	# params:
	#  $1 = device
	#  $2 = path to mounted media
	local ovlfile
	local mnt=$2
	local dev=$1

	cd /
	# look for apk overlays.
	ovlfile=$( find_ovl "$mnt" ) || return 1

	ebegin "Loading setup from $dev://$(basename $ovlfile)"
	# unpack the ovl
	mkdir -p "$TMP"
	if ! tar -C "$TMP" -zxf "$ovlfile" ; then
		eend $?
		return
	fi

	# copy the passwd file
	[ -f "$TMP/etc/passwd" ] && cp $TMP/etc/passwd /etc
	[ -f "$TMP/etc/group" ] && cp $TMP/etc/group /etc

	# install the packages
	load_pkgs $dev $mnt

	# copy the config
	merge_config
	eend $?

	# clean up
	rm -rf "$TMP"
}

# find where to install packages from
set_apk_path() {
	local dev fs mnt pref subdir
	# if pkg_path is not specified as kernel arg, look for the packages 
	# on mounted cdrom
	APK_PATH=`get_kopt pkg_path`
	APK_DEV=`get_kopt pkg_dev`

	# return if pkg_dev is empty
	if [ x"$APK_DEV" = x ] ; then
		export APK_PATH	
		return
	fi

	# split  dev:fs
	dev=`echo $APK_DEV | cut -d: -f1`
	fs=`echo $APK_DEV | cut -d: -f2`

	# find mountpoint in fstab
	mnt=$( awk '/^\/dev\/'$dev'/ { print $2 }' /etc/fstab )

	# remove leading '/media/'. we assume the mount is in /media
	prefix=${mnt#/media/}

	# if there is no mountpoint in /media, then append one
	if [ x"$prefix" = x"$mnt" ] || [ x"$mnt" = x ] ; then
		prefix=$dev
		echo -e "/dev/$dev\t/media/$prefix\t$fs\tnoauto\t0 0" >> /etc/fstab
		mkdir -p /media/$prefix
	fi

	# construct the URI
	subdir=`get_kopt pkg_subdir`
	APK_PATH=$prefix:/${subdir:-/apks}

	# read configs if available
	[ -f /etc/apk/apk.conf ] && . /etc/apk/apk.conf
	export APK_PATH
	export APK_PATH_MOUNTED=/media/$prefix/$subdir

}


start() {
	local cfgdevs  m
	# just in case...
	modprobe usb-storage 2>/dev/null
	modprobe sd_mod 2>/dev/null
	modprobe floppy 2>/dev/null
	modprobe cdrom 2>/dev/null
	
	set_apk_path

	cfgdevs=$( echo $( get_kopt cfg_dev ) | tr , ' ')
	for m in ${cfgdevs:-cdrom:iso9660 fd0:vfat usba1:vfat}; do
		local dev fs skip_umount mnt

		# split 'dev:fs'
		dev=${m%%:*}
		fs=${m##*:}

		# try to mount device on /mnt or abort
		mnt=$( awk '$1 ~ /^\/dev\/'$dev'/ { print $2 }' /proc/mounts )
		if [ x$mnt = x ] ; then
			skip_umount=""
			mount -t $fs -o ro /dev/$dev /mnt >/dev/null 2>&1 ||\
				continue
			mnt=/mnt
		else
			skip_umount=yes
		fi

		# look for package listings and config overlays
		load_pkgs_and_config $dev $mnt

		# lazy unmount
		[ x$skip_umount = xyes ] || umount -l $mnt
	done

	# if there are no /etc/apk/apk.conf, create one
	if ! [ -f /etc/apk/apk.conf ] ; then
		mkdir -p /etc/apk
		echo "APK_PATH=$APK_PATH" > /etc/apk/apk.conf
	fi
}

